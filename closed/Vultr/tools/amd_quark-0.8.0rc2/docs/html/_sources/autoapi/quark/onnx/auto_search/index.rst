:orphan:

:py:mod:`quark.onnx.auto_search`
================================

.. py:module:: quark.onnx.auto_search


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   quark.onnx.auto_search.AssembleIdxs
   quark.onnx.auto_search.SearchSpace



Functions
~~~~~~~~~

.. autoapisummary::

   quark.onnx.auto_search.l2_metric
   quark.onnx.auto_search.l1_metric
   quark.onnx.auto_search.cos_metric
   quark.onnx.auto_search.psnr_metric
   quark.onnx.auto_search.ssim_metric
   quark.onnx.auto_search.buildin_eval_func



.. py:function:: l2_metric(base_input: Any, ref_input: Any) -> Any

   Calculate the L2 metric between baseline and reference inputs.

   Args:
       base_input: Baseline input as a numpy array of float32.
       ref_input: Reference input as a numpy array of float32.

   Returns:
       The L2 metric as a float32 value.

   Note:
       Only np.ndarray datatype is accepted as input.


.. py:function:: l1_metric(base_input: Any, ref_input: Any) -> Any

   Calculate the L1 metric between baseline and reference inputs.

   Args:
       base_input: Baseline input as a numpy array of float32.
       ref_input: Reference input as a numpy array of float32.

   Returns:
       The L1 metric as a float32 value.

   Note:
       Only np.ndarray datatype is accepted as input.


.. py:function:: cos_metric(base_input: Any, ref_input: Any) -> Any

   Calculate the cosine metric between baseline and reference inputs.

   Args:
       base_input: Baseline input as a numpy array of float32.
       ref_input: Reference input as a numpy array of float32.

   Returns:
       The cosine metric as a float32 value. Value range: [0.0, 1.0]

   Note:
       Only np.ndarray datatype is accepted as input.


.. py:function:: psnr_metric(base_input: Any, ref_input: Any) -> Any

   Calculate the psnr metric between baseline and reference inputs.

   Args:
       base_input: Baseline input as a numpy array of float32.
       ref_input: Reference input as a numpy array of float32.

   Returns:
       The psnr metric as a float32 value.

   Note:
       Only np.ndarray datatype is accepted as input.


.. py:function:: ssim_metric(base_input: Any, ref_input: Any) -> Any

   Calculate the ssim metric between baseline and reference inputs.

   Args:
       base_input: Baseline input as a numpy array of float32.
       ref_input: Reference input as a numpy array of float32.

   Returns:
       The ssim metric as a float32 value.

   Note:
       Only np.ndarray datatype is accepted as input.


.. py:function:: buildin_eval_func(onnx_path: str, data_reader: Any, save_path: str = '', save_prefix: str = 'iter_x_') -> str

   Buildin evalation function using data_reader

   Args:
       onnx_path: onnx model path that will excute evalution, it can be  either float porint or quantized onnx model
       data_reader: user defined data_reader
       save_path: path used to save the output result
       save_prefix: prefix string used to name the saved output

   Note: Data reader here should be defined as dataloader.Because the raw data reader is iterator, it's
          not convient for evaluation.


.. py:class:: AssembleIdxs(values_idxs: Any)


   List all the combination of one list.
   Example:
           input_idxs: [[1,2,], [3,4]]
           output: [[1,3], [1,4], [2,3], [2,4]]

   Args:
       values_idxs

   Note:
       Only list the item in the input[i] list.

   .. py:method:: search_forward(item_forward: list[Any]) -> None

      Recresively find the next item until the last one.

      Args:
          item_forward: searched item collection.


   .. py:method:: run() -> list[Union[int, list[int]]]

      Excute the assemble process and return the result



.. py:class:: SearchSpace(conf: Dict[str, Any])


   Build the all possible search space from the input.
   # TODO remove the invalid config generated by the search space
   # TODO give the config priority
   # TODO validate the space dict right

   Args:
       config: config which includes the search space defined by the list

   Note:
       Because the search space is in difference levels, so we need to split the level of the search space.

   .. py:method:: three_level_spaces() -> list[Any]

      According to the user defined search space, list all the possible configs.
      There several situation we need to tell it apart(splited spaces):
      leve11 + level2
      level1 + level3
      level1 + level3
      level1



